---
title: "Worker Script Report: Populate Cipit Tables"
author: "Taylor Heffernan, Brian Cruice"
date: "`r lubridate::now()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#database packages
library(odbc)

#data manipulation packages
library(tidyverse)

#hashing packages
library(digest)

#Other stuff
library(knitr)
options(stringsAsFactors = FALSE)

# ODBC Connection to CIPIT
cipit <- dbConnect(odbc(),
    Driver = "ODBC Driver 17 for SQL Server", 
    Server = "PWDCIPSQLR", 
    Database = "CIPITREADER", 
    uid = 'cipreadonly', 
    pwd = 'cipread')

mars <- dbConnect(odbc(), "mars14_datav2")

errorCodes <- data.frame(code = 0:3,
  message = c("Execution successful.",
              "Could not connect to DB. Is Postgres or CIPIT down?",
              NA, #Write error from TryCatch will be used
              NA #Write error from TryCatch will be used
              ), stringsAsFactors=FALSE)

keepRunning = TRUE
success = FALSE
errorCode = 0

  #################################
  ####Error check - Did we connect?
  #################################
  if(any(!odbc::dbIsValid(mars), !odbc::dbIsValid(cipit)))
  {
    keepRunning = FALSE
    errorCode = 1
  }
```

## Worker Script Report: Populate CIPIT Tables

This script is attempting to connect to the database `CIPITREADER` on the `PWDCIPSWLR` server. Once connected, the script will query data from `CIPITREADER`, hash rows of data, and compare the hashes from `CIPITREADER` to those stored on `mars_data`.

```{r Section 1 - Querrying and Hashing, echo = FALSE, include = FALSE, eval = keepRunning}
cipit_project_query <- 'select _Work_Number as worknumber, _Project_Phase as project_phase, _Project_Phase_Status as project_phase_status, _Project_Title as project_title, _Targeted_Bid_FY as targeted_bid_fy, PC_NTP_Date as pc_ntp_date, CONST_Construction_Start_Date as construction_start_date, DESIGN_Design_Engineer as design_engineer, CONST_Division_Engineer as division_engineer, CONST_Contractor as contractor, ProjectAutoID as projectautoid, CONST_Substantially_Complete_Date as construction_complete_date, CONST_Contract_Close_Date as contract_closed_date from Project'
cipit_project <- dbGetQuery(cipit, cipit_project_query)

cipit_project$targeted_bid_fy <- as.numeric(cipit_project$targeted_bid_fy)

cipit_project_hash <- cipit_project %>%
    unite("temp", remove = FALSE) %>%
    rowwise() %>%
    mutate(md5hash = digest(temp, algo = 'md5')) %>%
    select(-temp)

cipit_project_db <- dbGetQuery(mars, "select * from external.tbl_cipit_project")

cipit_project_anti <- anti_join(cipit_project_hash, cipit_project_db)
cipit_project_new <- filter(cipit_project_anti,!(worknumber %in% cipit_project_db$worknumber))

cipit_project_update = anti_join(cipit_project_anti, cipit_project_new) %>%
    left_join(select(cipit_project_db, cipit_project_uid, worknumber))
```

```{r Section 2 - Comparing Databases and Writing to Databases, echo = FALSE, eval = all(keepRunning, nrow(cipit_project_new) > 0)}
knitr::asis_output(paste0("###CIPIT contains ", nrow(cipit_project_new), " new projects."))
kable(head(cipit_project_new))


tryCatch(

  expr = {
    dbWriteTable(mars, 
      DBI::SQL("external.tbl_cipit_project"), 
      cipit_project_new, 
      append= TRUE, 
      row.names = FALSE)
    success <<- TRUE
    },
  error = function(e) {
    keepRunning <<- FALSE
    errorCode <<- 2
    errorCodes$message[errorCode+1] <<- e$message #Error object is a list
  }
)

```

```{r Section 3: Updating existing records, echo = FALSE, eval = all(keepRunning, nrow(cipit_project_update) > 0)}
knitr::asis_output(paste0("###CIPIT contains ", nrow(cipit_project_update), " updated projects."))
kable(head(cipit_project_update))

tryCatch(

  expr = {
    update_cipit_project <- dbSendQuery(mars, 'update external.tbl_cipit_project set worknumber=?, project_phase=?, project_phase_status=?, project_title=?, targeted_bid_fy=?, pc_ntp_date=?, construction_start_date=?, design_engineer=?, division_engineer=?, contractor=?, projectautoid=?, construction_complete_date=?, contract_closed_date=?, md5hash=? where cipit_project_uid=?')
    dbBind(update_cipit_project, cipit_project_update)
    dbClearResult(update_cipit_project)
    success <<- TRUE
    },
  error = function(e) {
    keepRunning <<- FALSE
    errorCode <<- 3
    errorCodes$message[errorCode+1] <<- e$message #Error object is a list
  }
)

    

```

# Script Results: `r ifelse(keepRunning, "SUCCESS", ifelse(success, "PARTIAL FAILURE", "FAILURE"))`
## Exit Code: `r errorCode`
## Exit Message: `r errorCodes$message[errorCode+1]`

```{r Section 3 - Close DB connections and render this file, include = FALSE}
# Close database connections
dbDisconnect(mars)
dbDisconnect(cipit)

```

