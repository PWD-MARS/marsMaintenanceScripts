---
title: "Update Water in Cellar Complaints App-Version 2.0"
author: "Farshad Ebrahimi"
date: "`r lubridate::now()`"
output: html_document
params:
  database: mars14_datav2
  write: TRUE
---

# 0.0 Set Up {.hidden .unlisted}

```{r setup libraries and place holder data structures, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
  knitr::opts_chunk$set(echo = TRUE)
  knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

 # Install required package
  library(DBI)
  library(odbc)
  library(tidyverse)
  library(sf)
  library(lubridate)
  library(knitr)
  library(RPostgres)
  #Not in logical
`%!in%` <- Negate(`%in%`)

  # #replace special characters with friendlier characters
  special_char_replace <- function(note){

    note_fix <- note %>%
      str_replace_all(c("•" = "-", "ï‚§" = "-", "“" = '"', '”' = '"'))

    return(note_fix)

  }

 # DB connections
  #mars_con <- dbConnect(odbc(), dsn = params$database, uid = Sys.getenv("shiny_uid"), pwd = Sys.getenv("shiny_pwd"))
  
  mars_con <- dbConnect(RPostgres::Postgres(),
                        host = "PWDMARSDBS1.pwd.phila.local",
                        port = 5434,
                        dbname = "mars_data",
                        user = "mars_admin",
                        password = "lepton-gossip-underreact-polo-chair")
  
  cityworks_con <- dbConnect(odbc(),
                  Driver = "ODBC Driver 17 for SQL Server",
                  Server = "PWDCWSQLP",
                  Database = "PWD_Cityworks",
                  uid = Sys.getenv("cw_uid"),
                  pwd= Sys.getenv("cw_pwd"))
  
  gisdata_con <- dbConnect(odbc(),
                  Driver = "ODBC Driver 17 for SQL Server",
                  Server = "PWDGISSQL",
                  Database = "GISDATA",
                  uid = Sys.getenv("gis_uid"),
                  pwd= Sys.getenv("gis_pwd"))
  
  gisapps_con <- paste0("MSSQL:server=PWDGISSQL;",
                            "database=GIS_APPS;",
                            "UID=", Sys.getenv("gis_uid"), ";",
                            "PWD=", Sys.getenv("gis_pwd"), ";")

```

# 1. Prepping the Raw Cityworks Data

```{r 1. Prepping the data for storage in MARS DB (renaming, deduplicating, type cast etc), include=FALSE}
 # cityworks wic orders and comments tables
   cw_workorders <- dbGetQuery(cityworks_con, "SELECT wo.WORKORDERID, wo.INITIATEDATE AS date,     wo.LOCATION, wo.WOXCOORDINATE, wo.WOYCOORDINATE, woe.ENTITYUID AS FACILITYID 
   FROM Azteca.WORKORDER wo INNER JOIN Azteca.ACTIVITYLINK rwo ON wo.WORKORDERID = rwo.DESTACTIVITYSTRINGID and SOURCEACTIVITYTYPE = 'servicerequest' and DESTACTIVITYTYPE = 'workorder'
   LEFT JOIN Azteca.REQUEST r ON rwo.SOURCEACTIVITYID = r.REQUESTID 
   LEFT JOIN Azteca.WORKORDERENTITY woe ON wo.WORKORDERID = woe.WORKORDERID 
   WHERE ((wo.DESCRIPTION = 'A - PROPERTY INVESTIGATION' AND r.DESCRIPTION = 'WATER IN CELLAR') OR
   (wo.DESCRIPTION = 'A - LEAK INVESTIGATION' AND r.DESCRIPTION = 'WATER IN CELLAR'))
      ")
   cw_comments <- dbGetQuery(cityworks_con, "SELECT COMMENTID, WORKORDERID, COMMENTS from Azteca.WORKORDERCOMMENT")

 # Make names & data format consistent 
   names(cw_workorders) <- c("workorder_id","date","address","xcoordinate","ycoordinate","facility_id")
   names(cw_comments) <- c("comment_id","workorder_id","comment")
   
 # cast types    
   cw_workorders$date <- as.Date(cw_workorders$date)
   cw_workorders$workorder_id <- as.numeric(cw_workorders$workorder_id)
   cw_comments$workorder_id <- as.numeric(cw_comments$workorder_id)
   
 # de-duplicate workorders
   # get duplicated work orders
   duped_ids <- cw_workorders %>%
     mutate(dupe = duplicated(workorder_id)) %>%
     filter(dupe == TRUE) 
   
   # filter cw_workorders df to only duplicated workorder ids
   duped_workorders <- cw_workorders %>%
     filter(workorder_id %in% duped_ids$workorder_id)
   
   # remove the duplicated work orders from the main df and bind it after de-duplication
   nonduped_workorders <- cw_workorders %>%
     filter(workorder_id %!in% duped_ids$workorder_id)
   
   # for duped workorders, retain only 1 entry per address, prioritize the entry with non-zero facility id (xy coordinates are the same across dupes). Exclude empty addresses. 
   de_duped_waddress <- duped_workorders %>%
     filter(facility_id != "0" & address !="") %>%
     group_by(address) %>%
     summarise(facility_id = facility_id[1], workorder_id = workorder_id[1], xcoordinate = xcoordinate[1], ycoordinate = xcoordinate[1], date = date[1])
   
   # for empty address, prioritize non-zero facility id (pick the first row if more than 1 non-zero)
   de_duped_noaddress <- duped_workorders %>%
     filter(address == "") %>%
     group_by(facility_id) %>%
     summarise(workorder_id = workorder_id[1], address = address[1], xcoordinate = xcoordinate[1], ycoordinate = xcoordinate[1], date = date[1]) 

   # bind dfs
   cw_workorders <- bind_rows(nonduped_workorders, de_duped_waddress, de_duped_noaddress)
   
   # filter comments to WIC related ones
   cw_comments <- cw_comments %>%
     filter(workorder_id %in% cw_workorders$workorder_id)

```

# 2. Processing New/Changed WICs

## 2.1 Identifying New/Changed WICs & Comments

```{r 2.1 Checking for new WIC complaints, new WIC comments and changed ones, include=FALSE}
   
 # MARS wic and comments
   mars_workorders <- dbGetQuery(mars_con, "SELECT * FROM fieldwork.beta_tbl_wic_workorder")
   mars_comments <- dbGetQuery(mars_con, "SELECT * FROM fieldwork.beta_tbl_wic_comment")
   
 # remove \r & \n for the sake of comparison and replace special char
   mars_comments$comment <- gsub("[\r\n]", "", mars_comments$comment)
   cw_comments$comment <- gsub("[\r\n]", "", cw_comments$comment)
   
   comment_nobackslash <- gsub('\'', '\'\'',  cw_comments$comment)
   cw_comments$comment <- special_char_replace(comment_nobackslash)

 # New WICs
   new_wic <- cw_workorders %>%
     filter(workorder_id %!in% mars_workorders$workorder_id)
   
 # Changed WICs
   changed_wic <- cw_workorders %>%
     filter(workorder_id %!in% new_wic$workorder_id) %>%
     anti_join(mars_workorders, by = c("workorder_id", "date","address","xcoordinate","ycoordinate","facility_id"))
   
 # New Comments
   new_comment <- cw_comments %>%
     filter(comment_id %!in% mars_comments$comment_id)
   
 # Changed Comments
   changed_comment <- cw_comments %>%
     filter(comment_id %!in% new_comment$comment_id) %>%
     anti_join(mars_comments, by = c("workorder_id", "comment", "comment_id"))
  
```

Number of New Work Orders: `r nrow(new_wic)` Number of Changed Work Orders: `r nrow(changed_wic)`

Number of New Comments: `r nrow(new_comment)` Number of Changed Comments: `r nrow(changed_comment)`

## 2.2 Write New Work Orders to MARS DB {.hidden .unlisted}

```{r 2.2 Writing workorders to MARS DB, eval= params$write == TRUE & nrow(new_wic) > 0, include=FALSE}

 # add new work orders
   success_wo <- dbWriteTable(mars_con, Id(schema = "fieldwork", table = "beta_tbl_wic_workorder"), new_wic, append= TRUE, row.names = FALSE )

```

## 2.3 Update Changed Work Orders in MARS DB {.hidden .unlisted}

```{r 2.3 Updating changed workorders to MARS DB, eval= params$write == TRUE & nrow(changed_wic) > 0, include=FALSE}
 # update changed work orders
   for (i in 1:nrow(changed_wic)) {
     
      wo_sql_string <- sprintf(
      "UPDATE fieldwork.beta_tbl_wic_workorder SET date = '%s', address = '%s',  xcoordinate = %s, ycoordinate= %s,facility_id = '%s' WHERE workorder_id = %s;",
      changed_wic$date[i],
      changed_wic$address[i],
      changed_wic$xcoordinate[i],
      changed_wic$ycoordinate[i],
      changed_wic$facility_id[i],
      changed_wic$workorder_id[i]
   )

  # Execute the update statement
   success_upwo <- dbSendStatement(mars_con, wo_sql_string)
}
     
```

## 2.4 Write New Comments to MARS DB {.hidden .unlisted}

```{r 2.4 Writing New Comments to MARS DB, eval= params$write == TRUE & nrow(new_comment) > 0, include=FALSE}

 # add new comments
   success_comments <- dbWriteTable(mars_con, Id(schema = "fieldwork", table = "beta_tbl_wic_comment"), new_comment, append= TRUE, row.names = FALSE )

```

## 2.5 Update Changed Comments in MARS DB {.hidden .unlisted}

```{r 2.5 Updating changed comments to MARS DB, eval= params$write == TRUE & nrow(changed_comment) > 0, include=FALSE}

 # update changed comments
   for (i in 1:nrow(changed_comment)) {
     
      upcomm_sql_string <- sprintf(
      "UPDATE fieldwork.beta_tbl_wic_comment set comment = '%s' WHERE workorder_id = %s AND comment_id = %s;",
      changed_comment$comment[i],
      changed_comment$workorder_id[i],
      changed_comment$comment_id[i]
   )

  # Execute the update statement
  success_upcomments <- dbSendStatement(mars_con, upcomm_sql_string)
}

```

# 3. Attaching Parcels to WIC Workorders

## 3.1 Joining by Address {.hidden .unlisted}

```{r 3.1 Attaching Parcels to WIC Workorders based on address, eval= nrow(cw_workorders) > 0, include=FALSE}

 # pull pwd parcels (a large shapefile on the server which st_read fails to scrape from gis db)
  pwd_parcels_sf <- st_read(dsn = "\\\\pwdoows\\oows\\Watershed Sciences\\GSI Monitoring\\09 GIS Data\\PWD_PARCELS ", layer = "PWD_PARCELS")%>%
    select(gis_address = ADDRESS, gis_facility_id = FACILITYID)
 # non-spatial version
  pwd_parcels_df <- pwd_parcels_sf %>%
    st_set_geometry (NULL)
  
 # Join by address (primary attribute for matching)
  wicparcel_join_address <- cw_workorders %>%
    inner_join(pwd_parcels_df, by = c("address" = "gis_address")) %>%
    select(workorder_id, address, facility_id = gis_facility_id)

```

## 3.2 Joining by Facility IDs {.hidden .unlisted}

```{r 3.2 Attaching Parcels to WIC Workorders based on facility id, eval= nrow(cw_workorders) > 0, include=FALSE}

 # Join by address (secondary attribute for matching)
  wicparcel_join_facilityid <- cw_workorders %>%
    filter(workorder_id %!in% wicparcel_join_address$workorder_id) %>%
    inner_join(pwd_parcels_df, by = c("facility_id" = "gis_facility_id")) %>%
    select(workorder_id, address = gis_address, facility_id)

```

## 3.3 Intersect WIC XY Coordinates with PWD Parcels to Detect Parcels {.hidden .unlisted}

```{r 3.3 Intersecting WIC XY Coordinates with PWD Parcels, eval= nrow(cw_workorders) > 0, include=FALSE}
  
  # get remaining unverified work orders
  xy_wics <- cw_workorders %>%
    filter(workorder_id %!in% wicparcel_join_address$workorder_id & workorder_id %!in% wicparcel_join_facilityid$workorder_id) %>%
    filter(!is.na(xcoordinate) & !is.na(ycoordinate))

  # Build the spatial object from the XY coordinates 
  xy_vectors <-  c(xy_wics[,"xcoordinate"], xy_wics[,"ycoordinate"])

  xy_matrix <- matrix(data = xy_vectors, ncol = 2) %>% 
    na.omit
        
  xy_wic_sf <- xy_matrix %>%  
           as.matrix() %>%  
           st_multipoint() %>%  
           st_sfc() %>%  
           st_cast('POINT')
         
  st_crs(xy_wic_sf) <- 2272
         
  # Intersect the Parcel polygons and the point
  xy_wic_intersect <- st_intersects(xy_wic_sf, pwd_parcels_sf)
  
  # extract the pwd_parcels_df & xy_wics row numbers from xy_wic_intersect 
  wo_index <- NULL
  parcel_index <- NULL
  
  for(i in 1:length(xy_wic_intersect)) {
      parcel_index_temp <- xy_wic_intersect[[i]]
      if (length(parcel_index_temp) > 0) {
        wo_index_temp <- rep(i, length(parcel_index_temp))
        wo_index <- c(wo_index, wo_index_temp)
        parcel_index <- c(parcel_index, parcel_index_temp) 
      }
  }
 # Use work order id index (wo_index vector) and pwd_parcels_df index (parcel_index vector) to grab the right rows and bind the resulting columns 
 wicparcel_xy <- bind_cols(xy_wics[wo_index, ], pwd_parcels_df[parcel_index, ]) %>%
   select(workorder_id, address = gis_address, facility_id = gis_facility_id)

```

## 3.4 Bind WIC Parcels & Find New/Changed WIC Parcels

```{r 3.4 Binding the WIC parcels, pulling wic parcels from MARS DB and compare, eval= nrow(wicparcel_xy) > 0 | nrow(wicparcel_join_facilityid) > 0 | nrow(wicparcel_join_address) > 0, include=FALSE}

 # Bind the WIC parcels
  wic_parcels <- bind_rows(wicparcel_join_address, wicparcel_join_facilityid, wicparcel_xy)
 
 # pull wic parcels from MARS DB
  mars_wic_parcels <- dbGetQuery(mars_con, "SELECT * FROM fieldwork.beta_tbl_wic_parcel")
  
 # new wic parcel
  new_wic_parcel <- wic_parcels %>%
    filter(workorder_id %!in% mars_wic_parcels$workorder_id)
  
 # changed wic parcel
  changed_wic_parcel <- wic_parcels %>%
    filter(workorder_id %!in% new_wic_parcel$workorder_id) %>%
    anti_join(mars_wic_parcels, by = c("workorder_id", "address", "facility_id"))
    
```

Number of New WIC Parcels: `r nrow(new_wic_parcel)`

Number of Changed WIC Parcels: `r nrow(changed_wic_parcel)`

## 3.5 Add WIC Parcels to MARS DB {.hidden .unlisted}

```{r 3.5 Writing new wic parcels to MARS DB , eval= params$write == TRUE & nrow(new_wic_parcel) > 0, include=FALSE}
  # add new wic parcels
   success_wicparcels <- dbWriteTable(mars_con, Id(schema = "fieldwork", table = "beta_tbl_wic_parcel"), new_wic_parcel, append= TRUE, row.names = FALSE )

```

## 3.6 Update WIC Parcels in MARS DB {.hidden .unlisted}

```{r 3.6 Updating changed wic parcels in MARS DB , eval= params$write == TRUE & nrow(changed_wic_parcel) > 0, include=FALSE}
   # update changed wic parcels
   for (i in 1:nrow(changed_wic_parcel)) {
     
      upwicparcel_sql_string <- sprintf(
      "UPDATE fieldwork.beta_tbl_wic_parcel set address = '%s', facility_id = '%s' WHERE workorder_id = %s;",
      changed_wic_parcel$address[i],
      changed_wic_parcel$facility_id[i],
      changed_wic_parcel$workorder_id[i]
   )

  # Execute the update statement
  success_upwicparcel <- dbSendStatement(mars_con, upwicparcel_sql_string)
}

```

# 4. Add Spatial Polygons

## 4.1 Identify New WIC Polygons (Property & Footprint)

```{r 4.1 Identifying New WIC Polygons, include=FALSE}
 # pull footprint parcels    
 footprint_sf <- st_read(dsn = "\\\\pwdoows\\oows\\Watershed Sciences\\GSI Monitoring\\09 GIS Data\\Building_Footprint_Shapefile", layer = "Building_Footprint") 
 footprint_sf <- footprint_sf %>%
   select(address = ADDRESS)
 
 # pull MARS's spatial polygons
  mars_footprint_sf  <- st_read(dsn = mars_con, Id(schema="fieldwork", table = "beta_tbl_wic_footprint_geom"))
  mars_propertyline_sf  <- st_read(dsn = mars_con, Id(schema="fieldwork", table = "beta_tbl_wic_propertyline_geom"))
  mars_smp_sf  <- st_read(dsn = mars_con, Id(schema="fieldwork", table = "beta_tbl_wic_smp_geom"))

 # find wic property lines
 wic_propertyline_sf <- pwd_parcels_sf %>%
   filter(gis_address %in% wic_parcels$address) %>%
   select(address = gis_address, propertyline_geom = geometry)
 
 # Combine geometries per address
 wic_propertyline_combined_sf <- wic_propertyline_sf %>%
   group_by(address) %>%
   summarize(propertyline_geom = st_combine(propertyline_geom)) %>%
   st_as_sf() 
   
 new_wic_propertyline_sf <- wic_propertyline_combined_sf %>%
   filter(address %!in% mars_propertyline_sf$address)
 
  # find wic footprints
 wic_footprint_sf <- footprint_sf %>%
   filter(address %in% wic_parcels$address) %>%
   select(address, footprint_geom = geometry)
 
  # Combine geometries per address
 wic_footprint_combined_sf <- wic_footprint_sf %>%
   group_by(address) %>%
   summarize(footprint_geom = st_combine(footprint_geom)) %>%
   st_as_sf() 
 
 new_wic_footprint_sf <- wic_footprint_combined_sf %>%
   filter(address %!in% mars_footprint_sf$address) 
 
```

Number of New WIC Property Lines Geometry: `r nrow(new_wic_propertyline_sf)`

Number of New WIC Footprints Geometry: `r nrow(new_wic_footprint_sf)`

## 4.2 Add WIC Polygons to MARS DB {.hidden .unlisted}

### 4.2.1 Add Property Lines {.hidden .unlisted}

```{r 4.2.1 Add WIC Property Lines in MARS DB, eval= params$write == TRUE & nrow(new_wic_propertyline_sf) > 0, include=FALSE}

  # add new wic propertylines
   success_property_sf <- st_write(obj = wic_propertyline_combined_sf, dsn = mars_con, Id(schema="fieldwork", table = "beta_tbl_wic_propertyline_geom"), append = TRUE)

```

### 4.2.2 Add Footprints {.hidden .unlisted}

```{r 4.2.2 Add WIC Footprints in MARS DB, eval= params$write == TRUE & nrow(new_wic_footprint_sf) > 0, include=FALSE}

  # add new wic footprints
   success_footprint_sf <- st_write(obj = wic_footprint_combined_sf, dsn = mars_con, Id(schema="fieldwork", table = "beta_tbl_wic_footprint_geom"), append = TRUE)

```

## 4.3 Identify New SMP Polygons

```{r 4.3 Identify New SMP polygons, include=FALSE}
  # pull mars polygons
  mars_smp_sf <- dbGetQuery(mars_con, "SELECT * FROM fieldwork.beta_tbl_wic_smp_geom")

  # SMP Polygons from GIS. all CRS set at 2272 coordinate system to be consistent with pwd_parcels and footprint CRS
  basin <- suppressWarnings(st_read(gisapps_con, "gisad.GSWIBASIN", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  blueroof <- suppressWarnings(st_read(gisapps_con, "gisad.GSWIBLUEROOF", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  bumpout <- suppressWarnings(st_read(gisapps_con, "gisad.GSWIBUMPOUT", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  cistern <- suppressWarnings(st_read(gisapps_con, "gisad.GSWICISTERN", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  greenroof <- suppressWarnings(st_read(gisapps_con, "gisad.GSWIGREENROOF", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  permeablepavement <- suppressWarnings(st_read(gisapps_con, "gisad.GSWIPERMEABLEPAVEMENT", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  planter <- suppressWarnings(st_read(gisapps_con, "gisad.GSWIPLANTER", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  raingarden <- suppressWarnings(st_read(gisapps_con, "gisad.GSWIRAINGARDEN", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  swale <- suppressWarnings(st_read(gisapps_con, "gisad.GSWISWALE", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  treetrench <- suppressWarnings(st_read(gisapps_con, "gisad.GSWITREETRENCH", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  trench <- suppressWarnings(st_read(gisapps_con, "gisad.GSWITRENCH", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  wetland <- suppressWarnings(st_read(gisapps_con, "gisad.GSWIWETLAND", quiet = TRUE)) %>%
            st_set_crs(2272) %>%
            select(smp_id = SMP_ID)
  
  # single sf with no NA
  smp_sf <- bind_rows(basin, blueroof, bumpout, cistern, greenroof, permeablepavement, planter, raingarden, swale, treetrench, trench, wetland) %>%
    distinct() %>%
    na.omit() %>%
    group_by(smp_id) %>%
    summarize(SHAPE = st_combine(SHAPE)) %>%
    st_as_sf()

  # filter SMPs to public ones
  smp_sf["public"] <- grepl ("\\d+-\\d+-\\d+", smp_sf[["smp_id"]])
  smp_sf <- smp_sf %>%
    filter(public == TRUE) %>%
    select(-public)
  
  # New Polygons
  new_smp_sf <- smp_sf %>%
     filter(smp_id %!in% mars_smp_sf$smp_id) %>%
     select(smp_id, smp_geom = SHAPE)
  
```

Number of New SMP Geometry: `r nrow(new_smp_sf)`

## 4.4 Add New SMP Polygons to MARS DB {.hidden .unlisted}

```{r 4.4 New SMP Polygons WKTs in MARS DB, eval= params$write == TRUE & nrow(new_smp_sf) > 0, include=FALSE}
  # add new smp polygons with postgis
   success_smppoly <- st_write(obj = new_smp_sf, dsn = mars_con, Id(schema="fieldwork", table = "beta_tbl_wic_smp_geom"), append = TRUE)

```

# 5. Detect WICs around SMPs

## 5.1 Intersect WIC Parcels with SMP Polygons and Calculate Distance {.hidden .unlisted}

```{r 5.1 Intersect WIC Parcels with SMP Polygons and Calculate Distance, include=FALSE}

  # Create buffer 100 ft buffer around SMPs and intersect them with the WIC Parcels
  smp_sf_100ft <- st_buffer(smp_sf, 100)
  smp_wic_intersect <- st_intersects(smp_sf_100ft, wic_propertyline_combined_sf)
  
  intersecting_addresses <- wic_propertyline_combined_sf %>%
    st_set_geometry(NULL)
  intersecting_smps <- smp_sf_100ft %>%
    st_set_geometry(NULL)
  
  # placeholder
  smp_wic_df <- data.frame(smp_id = as.character(),
                           wic_address = as.character(),
                           property_dist_ft = as.numeric(),
                           footprint_dist_ft = as.numeric())

  # Develop a dataframe that associate smp_ids with wic property addresses- calculate wmp-wic distances too 
  for (i in 1:length(smp_wic_intersect)) {
    if (length(smp_wic_intersect[[i]]) > 0) {
      for (j in 1:length(smp_wic_intersect[[i]])) {
        wic_sf_index <- as.vector(smp_wic_intersect[[i]])
        # property distance
        temp_smp_wic_prop_dist <- st_distance(smp_sf[i, ], wic_propertyline_combined_sf[wic_sf_index[j], ])
        # footprint distance
        temp_smp_wic_footprint_dist <- st_distance(smp_sf[i, ], filter(wic_footprint_combined_sf, address == wic_propertyline_combined_sf[wic_sf_index[j], ]$address))
        # put the data in a dataframe- using minimum function for footprint in case there are several footprint polygons per address
        temp_smp_wic_df <- data.frame(smp_id = intersecting_smps[i, ], 
                                      wic_address = pull(intersecting_addresses[smp_wic_intersect[[i]][j],]),
                                      property_dist_ft = ifelse(length(temp_smp_wic_prop_dist) > 0, as.numeric(temp_smp_wic_prop_dist), NA),
                                      footprint_dist_ft = ifelse(length(temp_smp_wic_footprint_dist) > 0, min(as.numeric(temp_smp_wic_footprint_dist)), NA)
                                      )
        # bind rows
        smp_wic_df <- bind_rows(smp_wic_df, temp_smp_wic_df)
      }
    }
  }
  
  
```

## 5.2 Identify the WIC Construction Status {.hidden .unlisted}

```{r 5.2 Identify the WIC Construction Status, include=FALSE}
  # Getting the construction milestones dates
  cipit <- dbGetQuery(mars_con, "SELECT * FROM external.tbl_cipit_project")
  smpbdv <- dbGetQuery(mars_con, "SELECT * FROM  external.tbl_smpbdv")
  smp_milestones <- smpbdv %>%
    inner_join(cipit, by = "worknumber") %>%
    inner_join(smp_wic_df, by = "smp_id") %>%
    inner_join(wic_parcels, by = c("wic_address" = "address")) %>%
    inner_join(cw_workorders, by = "workorder_id") %>%
    select (smp_id, wic_address, date, property_dist_ft, footprint_dist_ft, construction_start_date, pc_ntp_date, construction_complete_date, contract_closed_date) %>%
    distinct()
  
  #setting the lookup_id's default in smp milestone to 4
  smp_milestones['con_phase_lookup_uid'] <- 4
  for(i in 1:nrow(smp_milestones)) {
    if (!is.na(smp_milestones[i, "construction_start_date"]) && !is.na(smp_milestones[i, "construction_complete_date"]) ) {
        if (smp_milestones[i, "date"] >= smp_milestones[i, "construction_start_date"] && smp_milestones[i, "date"] <= smp_milestones[i, "construction_complete_date"]  ) {
          smp_milestones[i, "con_phase_lookup_uid"] <- 1
        } else if (smp_milestones[i, "date"] < smp_milestones[i, "construction_start_date"]) {
          smp_milestones[i, "con_phase_lookup_uid"] <- 3
        } else {
          smp_milestones[i, "con_phase_lookup_uid"] <- 2
      }
    } else if (!is.na(smp_milestones[i, "pc_ntp_date"]) && !is.na(smp_milestones[i, "construction_complete_date"] )) {
        if (smp_milestones[i, "date"] >= smp_milestones[i, "pc_ntp_date"] && smp_milestones[i, "date"] <= smp_milestones[i, "construction_complete_date"]  ) {
          smp_milestones[i, "con_phase_lookup_uid"] <- 1
        } else if (smp_milestones[i, "date"] < smp_milestones[i, "pc_ntp_date"]) {
          smp_milestones[i, "con_phase_lookup_uid"] <- 3
        } else {
          smp_milestones[i, "con_phase_lookup_uid"] <- 2
      }
      
    } else if (!is.na(smp_milestones[i, "construction_start_date"]) && !is.na(smp_milestones[i, "contract_closed_date"])) {
        if (smp_milestones[i, "date"] >= smp_milestones[i, "construction_start_date"] && smp_milestones[i, "date"] <= smp_milestones[i, "contract_closed_date"]  ) {
          smp_milestones[i, "con_phase_lookup_uid"] <- 1
        } else if (smp_milestones[i, "date"] < smp_milestones[i, "construction_start_date"]) {
          smp_milestones[i, "con_phase_lookup_uid"] <- 3
        } else {
          smp_milestones[i, "con_phase_lookup_uid"] <- 2
      }
    } else if (!is.na(smp_milestones[i, "pc_ntp_date"]) && !is.na(smp_milestones[i, "contract_closed_date"])) {
        if (smp_milestones[i, "date"] >= smp_milestones[i, "pc_ntp_date"] && smp_milestones[i, "date"] <= smp_milestones[i, "contract_closed_date"]  ) {
          smp_milestones[i, "con_phase_lookup_uid"] <- 1
        } else if (smp_milestones[i, "date"] < smp_milestones[i, "pc_ntp_date"]) {
          smp_milestones[i, "con_phase_lookup_uid"] <- 3
        } else {
          smp_milestones[i, "con_phase_lookup_uid"] <- 2
        }
      
    } else { 
          smp_milestones[i, "con_phase_lookup_uid"] <- 4
      }
  }
  
  # prep the final table for writing in DB
  wic_smp <- smp_milestones %>%
    select(smp_id, wic_address, con_phase_lookup_uid, footprint_dist_ft, property_dist_ft) %>%
    distinct()

```

## 5.3 Identify New/Change SMP-WIC

```{r 5.3 Identify New/Change SMP-WIC, include=FALSE}
  mars_wic_smp <- dbGetQuery(mars_con, "SELECT * FROM fieldwork.beta_tbl_wic_smp")
  # New wic_smp
  new_wic_smp <- wic_smp %>%
     anti_join(mars_wic_smp, by = c("smp_id","wic_address"))
  
  # Changed wic_smp
  changed_wic_smp <- wic_smp %>%
     anti_join(new_wic_smp, by = c("smp_id","wic_address")) %>%
     anti_join(mars_wic_smp, by = c("smp_id","wic_address","con_phase_lookup_uid", "footprint_dist_ft", "property_dist_ft")) 
  
```

Number of New WICs within 100 ft of SMPs: `r nrow(new_wic_smp)`

Number of Changed WICs within 100 ft of SMPs: `r nrow(changed_wic_smp)`

## 5.4 Add New SMP-WIC to MARS DB {.hidden .unlisted}

```{r 5.4 Add New SMP-WIC to MARS DB, eval= params$write == TRUE & nrow(new_wic_smp) > 0, include=FALSE}
  # add new wic-smp
   success_wic_smp <- dbWriteTable(mars_con, Id(schema = "fieldwork", table = "beta_tbl_wic_smp"), new_wic_smp, append= TRUE, row.names = FALSE )

```

## 5.5 Update Changed SMP-WIC in MARS DB {.hidden .unlisted}

```{r Update Changed SMP-WIC in MARS DB, eval= params$write == TRUE & nrow(changed_wic_smp) > 0, include=FALSE}
  # update changed wic-smp
   for (i in 1:nrow(changed_wic_smp)) {
       upwicsmp_sql_string <- sprintf(
      "UPDATE fieldwork.beta_tbl_wic_smp
       SET con_phase_lookup_uid = '%s',
           footprint_dist_ft = '%s',
           property_dist_ft = '%s'
       WHERE wic_address = '%s' AND smp_id = '%s';",
      changed_wic_smp$con_phase_lookup_uid[i],
      changed_wic_smp$footprint_dist_ft[i],
      changed_wic_smp$property_dist_ft[i],
      changed_wic_smp$wic_address[i],
      changed_wic_smp$smp_id[i]
  )

  # Execute the update statement
  success_upwicsmp <- dbSendStatement(mars_con, upwicsmp_sql_string)
}

```

## 5.6 Summary Table of New/Changed WICs within 100 ft of SMPs

### 5.6.1 New WICs around SMPs (100 ft buffer) 

```{r Section 5.6.1- Summary Table of New WICs around SMPs, echo=FALSE, results='asis', eval= nrow(new_wic_smp)>0}
      # Prep the table
      new_wic_kable <- new_wic_smp %>%
        select(`SMP ID` = smp_id, `WIC Address` = wic_address, `Dist. Footprint (ft)` = footprint_dist_ft, `Dist. Property (ft)` = property_dist_ft)
      
      kable(new_wic_kable)

```

### 5.6.2 Changed WICs around SMPs (100 ft buffer) 

```{r Section 5.6.2 - Summary Table of Changed WICs around SMPs, echo=FALSE, results='asis', eval= nrow(changed_wic_smp)>0}
       # Prep the table
      changed_wic_kable <- changed_wic_smp %>%
        select(`SMP ID` = smp_id, `WIC Address` = wic_address, `Dist. Footprint (ft)` = footprint_dist_ft, `Dist. Property (ft)` = property_dist_ft)
      
      kable(changed_wic_kable)

```
