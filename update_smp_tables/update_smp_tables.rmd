---
title: "Worker Script Report: Update SMP Tables"
author:
- Taylor Heffernan
- Updating smp_loc and smp_gage
date: "`r lubridate::now()`"
output: html_document
params:
  database: "mars_testing" #One of mars or mars_testing. Requires a DSN of the same name.
  write: TRUE #Write changes to database?
---

```{r setup, include=FALSE}

#GIS stuff
library(rgdal)
library(sf)

#Dplyr stuff
library(magrittr)
library(tidyverse)

#Database Stuff
library(odbc)

#Other stuff
library(knitr)
options(stringsAsFactors=FALSE)

```

```{r Section 0 - Preamble and database connections, include=FALSE}
###Section 0.1: Check parameter validity

dsn_infra_pub <- paste0("MSSQL:server=pwdgis4;",
                        "database=INFRASTRUCTURE_PUBLIC;",
                        "UID=gisread;",
                        "PWD=gisread;")

###Section 0.2: Connect to the database
	#Indicate the database name: mars_testing or mars. 
	#Only write to mars if you really know what you're doing.
 	database <- params$database

 	#Connect using the DSN.
	marsDBCon <- dbConnect(odbc::odbc(), database)
 	
 	#This is required to append new data to database tables
	if(params$write == TRUE){

		#Refresh materialized view so it has the newest cache of SMP IDs
		#If we don't do this, new IDs won't be found, and we will get an insertion error.
		dbGetQuery(marsDBCon, "REFRESH MATERIALIZED VIEW smpid_facilityid_componentid WITH DATA;")
	  
	  #Grab universe of SMP IDs to filter SMP additions
	  valid_smps <- dbGetQuery(marsDBCon, "select distinct smp_id from smpid_facilityid_componentid") %>% pull(smp_id)
	}

```
  
This script is attempting to update the `smp_loc`, `smp_radarcell`, and `smp_gage` tables in the `r params$database` database. It grabs the WGS1984 SMP polygons from the `INFRASTRUCTURE_PUBLIC` database on PWDGIS4, converts them to centroids, and stores them in the smp_loc table. It then checks the `smp_id`s contained in `smp_loc` to see if any don't exist in `smp_gage`. If they don't, it calculates which rain gage is closest to that SMP's centroid. Finally, it repeats this process with radar grid cells. Radar grid cells are also stored as grid cell centroids.

```{r Section 1 - Gathering data for the smp_loc table, include = FALSE}
###Section 1: Update smp_loc table
###Check GIS data for any new SMPs, and insert them into smp_loc
	#Fetch current version of smp_loc
	smp_loc <- dbGetQuery(marsDBCon, "SELECT * FROM smp_loc")
	smp_loc$lon_wgs84 %>% as.numeric %>% round(4) -> smp_loc$lon_wgs84
	smp_loc$lat_wgs84 %>% as.numeric %>% round(4) -> smp_loc$lat_wgs84
	
	#Grab centroids of new SMPs
	basin <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIBASIN_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	blueroof <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIBLUEROOF_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	bumpout <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIBUMPOUT_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	cistern <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWICISTERN_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	drainagewell <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIDRAINAGEWELL_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	greenroof <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIGREENROOF_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	permeablepavement <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIPERMEABLEPAVEMENT_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	planter <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIPLANTER_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	raingarden <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIRAINGARDEN_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	swale <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWISWALE_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	treetrench <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWITREETRENCH_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	trench <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWITRENCH_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	wetland <- suppressWarnings(st_read(dsn_infra_pub, "gisad.GSWIWETLAND_WGS84", quiet = TRUE)) %>% 
	  st_centroid %>% filter(!is.na(SMP_ID)) %>% transmute(smp_id = gsub("\\s", "", SMP_ID)) %>%
	  filter(!(grepl("[A-z]", smp_id))) %>% #No A-Z characters permitted. Upper and lower case.
	  filter(!(smp_id %in% smp_loc$smp_id)) %>%
	  {data.frame(st_coordinates(.), .$smp_id)} %>%
	  select(smp_id = 3, lon_wgs84 = 1, lat_wgs84 = 2)

	#Stick them all together
	smp_locNewData <- bind_rows(basin, blueroof, bumpout, cistern, drainagewell, greenroof, permeablepavement, planter, raingarden, swale, treetrench, trench, wetland) %>% filter(smp_id %in% valid_smps)
	row.names(smp_locNewData) <- NULL

```


## Updates to `smp_loc` Table

New centroids have been exported and examined against the existing `smp_loc` table. There are `r nrow(smp_locNewData)` new centroids to add to the `smp_loc` table.

`r if(nrow(smp_locNewData) > 0){knitr::kable(smp_locNewData)}`

```{r Section 1.5 - Writing to the smp_loc table, include = FALSE}	
  #Fail safe. If the block below doesn't run, we didn't append anything
  outcome_centroids <- FALSE

  #If there's new data to append
	if(nrow(smp_locNewData) > 0 & params$write == TRUE){
    tryCatch({outcome_centroids <- dbWriteTable(marsDBCon, "smp_loc", smp_locNewData, append= TRUE, row.names = FALSE)}, # append the data
             error = function(e) e
    )
  }
```

New centroids have `r ifelse(outcome_centroids, "SUCCESSFULLY", "NOT")` been appended to the `smp_loc` table.

---  

```{r Section 2 - Gathering data for the smp_gage table, include = FALSE}
###Section 2: Update smp_gage table
  #Maintenance on smp_id tables
  #Separate queries because it deletes in ;-separated queries are not allowed in a single transaction
  dbGetQuery(marsDBCon, "REFRESH MATERIALIZED VIEW smpid_orphans WITH DATA;")
  dbGetQuery(marsDBCon, "delete from smp_loc where smp_id in (select smp_id from smpid_orphans)")
  dbGetQuery(marsDBCon, "delete from smp_gage where smp_id in (select smp_id from smpid_orphans)")
  dbGetQuery(marsDBCon, "delete from smp_radarcell where smp_id in (select smp_id from smpid_orphans)")

###If there are any SMPs with locations that do not have rain gage associations, apply those now
	#Read table of SMP locations (in case it got updated in step 1)
	smp_loc <- dbGetQuery(marsDBCon, "SELECT * FROM smp_loc")

	#Read table of SMP/rain gage associations
	smp_gage <- dbGetQuery(marsDBCon, "SELECT * FROM smp_gage")

	#Every SMP with a location should also have a rain gage. Find the ones that don't
	smp_loc_nogage <- anti_join(smp_loc, smp_gage, by = "smp_id")

	#If any SMPs don't have a gage
	if(nrow(smp_loc_nogage) > 0){
		#Fetch the rain gage locations from the database
		gage_loc <- dbGetQuery(marsDBCon, "SELECT * FROM gage_loc")
		
		#Create spatial data frames for SMPs and gages
		gage_loc_spatial <- st_as_sf(gage_loc, coords = c(3, 4))
		nogage_spatial <- st_as_sf(smp_loc_nogage, coords = c(3, 4))
		
		#Find nearest gage for new SMPs
		smp_loc_nogage <- data.frame(smp_id = nogage_spatial$smp_id, 
		                             gageindex = st_nearest_feature(nogage_spatial, gage_loc_spatial)) %>%
		  mutate(gage_uid = gage_loc_spatial$gage_uid[gageindex]) %>%
		  filter(!duplicated(smp_id)) %>%
		  select(smp_id, gage_uid)
	}
```

## Updates to `smp_gage` Table

The `smp_gage` table has been checked for SMPs without a rain gage association. There are `r nrow(smp_loc_nogage)` new entries to add to the `smp_gage` table.

`r if(nrow(smp_loc_nogage) > 0){knitr::kable(smp_loc_nogage)}`

```{r Section 2.5 - Writing to the smp_gage table, include = FALSE}
    #Fail safe. If the block below doesn't run, we didn't append anything
	outcome_gage <- FALSE

	#If there's new data to append
    if(nrow(smp_loc_nogage) > 0 & params$write == TRUE){
		  tryCatch({outcome_gage <- dbWriteTable(marsDBCon, "smp_gage", smp_loc_nogage, append= TRUE, row.names = FALSE)}, # append the data	
		           error = function(e) e
		  )
	  } 
```

New gage associations have `r ifelse(outcome_gage, "SUCCESSFULLY", "NOT")` been appended to the `smp_gage` table.  

---

```{r Section 3 - Gathering data for the smp_radarcell table, include = FALSE}
###Section 3: Update smp_radarcell table
###If there are any SMPs with locations that do not have radarcell associations, apply those now
	#Read table of SMP locations (in case it got updated in step 1)
	smp_loc <- dbGetQuery(marsDBCon, "SELECT * FROM smp_loc")

	#Read table of SMP/radarcell associations
	smp_radarcell <- dbGetQuery(marsDBCon, "SELECT * FROM smp_radarcell")

	#Every SMP with a location should also have a radarcell. Find the ones that don't
	smp_loc_noradarcell <- anti_join(smp_loc, smp_radarcell, by = "smp_id")

	#If any SMPs don't have a radarcell
	if(nrow(smp_loc_noradarcell) > 0){
		#Fetch the radarcell locations from the database
		radarcell_loc <- dbGetQuery(marsDBCon, "SELECT * FROM radarcell_loc")
		
		#Create spatial data frames for SMPs and radarcells
		radarcell_loc_spatial <- st_as_sf(radarcell_loc, coords = c(3, 4))
		noradarcell_spatial <- st_as_sf(smp_loc_noradarcell, coords = c(3, 4))
		
		#Find nearest radarcell for new SMPs
		smp_loc_noradarcell <- data.frame(smp_id = noradarcell_spatial$smp_id, 
		                             radarcellindex = st_nearest_feature(noradarcell_spatial, radarcell_loc_spatial)) %>%
		  mutate(radarcell_uid = radarcell_loc_spatial$radarcell_uid[radarcellindex]) %>%
		  select(smp_id, radarcell_uid)
	}
```

## Updates to `smp_radarcell` Table

The `smp_radarcell` table has been checked for SMPs without a radarcell association. There are `r nrow(smp_loc_noradarcell)` new entries to add to the `smp_radarcell` table.

`r if(nrow(smp_loc_noradarcell) > 0){knitr::kable(smp_loc_noradarcell)}`

```{r Section 3.5 - Writing to the smp_radarcell table, include = FALSE}
    #Fail safe. If the block below doesn't run, we didn't append anything
	outcome_radarcell <- FALSE

	#If there's new data to append
    if(nrow(smp_loc_noradarcell) > 0 & params$write == TRUE){
		  tryCatch({outcome_radarcell <- dbWriteTable(marsDBCon, "smp_radarcell", smp_loc_noradarcell, append= TRUE, row.names = FALSE)}, # append the data	
		           error = function(e) e
		  )
	  }
```

New radarcell associations have `r ifelse(outcome_radarcell, "SUCCESSFULLY", "NOT")` been appended to the `smp_radarcell` table.  

---

```{r Section 4 - Close DB connections and render this file, include = FALSE}
	#Close database connections
	dbDisconnect(marsDBCon)
```
